<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>{'default': 'Azeem Arshad', 'post': "Azeem's Blog"}</title>
        <link>http://azeemarshad.in</link>
        <description>Azeem Arshad's Home Page</description>
            <item>
                <title>Yago Loader</title>
                <link>http://azeemarshad.in/posts/yago_loader.html</link>
                <guid>http://azeemarshad.in/posts/yago_loader.html</guid>
                <description>
                    <![CDATA[
                        <p><a href="http://www.mpi-inf.mpg.de/yago-naga/yago/">Yago</a> is a huge semantic knowledge base, containing millions of facts about millions of entities (People, Organizations, Places etc.). I have been playing around with Yago some time back. I was going through the stuff again this weekend and I came across this small loader program that I had written back then.</p>

<p>The Yago core database is a 3.4Gb <a href="http://www.mpi-inf.mpg.de/yago-naga/yago/downloads.html">download</a>. It comes as a bunch of TSV (Tab Separated Values) files, one file for each predicate (Facts in knowledge bases are represented as triplets of subject, predicate, object). Each file contains tab separated ID, subject and predicate on every line. There is a <a href="http://www.mpi-inf.mpg.de/yago-naga/yago/download/yago2/yago2converters_20111027.7z">converter tool</a> also, that can load the TSV data into a database, but I wanted to try loading the files using <a href="http://dev.mysql.com/doc/refman/5.1/en/load-data.html">MySQL LOAD DATA INFILE</a> statement. LOAD DATA INFILE lets you bulk load a file into a table, thus ridding the need to run INSERT statements.  My loader program simply reads a TSV file and creates a temporary file containing the rows to be loaded into the database table and then runs LOAD DATA INFILE statement.</p>

<div data-gist-id="1103406"><a href="http://gist.github.com/1103406">Yago Loader</a></div>

<p>Using the <code>--exclude</code> option and <code>--log</code> option with the same argument will exclude files in the log. This would allow us to stop the loading at any point and resume, some time later, with the TSV file that it stopped at.</p>

                    ]]>
                </description>
            </item>
            <item>
                <title>Diagram connector routing</title>
                <link>http://azeemarshad.in/posts/diagram_connector_routing.html</link>
                <guid>http://azeemarshad.in/posts/diagram_connector_routing.html</guid>
                <description>
                    <![CDATA[
                        <p>I have been trying to find some interesting coding stuff to work on, something to get off of the
line of work that i do at my day job, relive the college days :P. This is an interesting
problem that came up when i tried to dust off one of my old javascript projects. In simple words, the
problem goes something like this: given a flow chart, how do you automatically render orthogonal
flow lines without intersections or collisions.</p>

<p><a href="http://pipes.yahoo.com/pipes/">Yahoo pipes</a> was sort of like a reference design for my project. But i wanted clean
orthogonal connecting lines that avoided each other, unlike the curvy pipes that would go
behind components. Interestingly, i could find some nice javascript libraries: <a href="http://neyric.github.com/wireit/">WireIt</a>,
<a href="http://jsplumb.org/jquery/demo.html">jsPlumb</a>, <a href="http://www.jointjs.com/">joinjs</a> etc. that takes care of computing/rendering the connectors etc.
Regardless, in the DIY spirit, (or rather, the Reinvent The Wheel Yourself spirit :P) i started
to prototype.</p>

<p>The underlying problem is path search. A 2D canvas can be treated as a <a href="http://en.wikipedia.org/wiki/Graph_(mathematics)">Graph</a>, where each
pixel is represented by a node (lets say we represent a pixel (x,y) with node [x,y]). Obviously, pixels
that collide with chart components or other flowlines will have no corresponding nodes. Since
we are interested only in orthogonal paths, we create edges from each node to its four
orthogonal neighbours (ie. [x,y-1], [x-1,y], [x,y+1], [x+1,y]). The problem of finding
orthogonal flow line from point (x,y) to (x',y') can now be treated as the problem of finding
a path from node [x,y] to [x',y'], which can be easily solved by <a href="http://en.wikipedia.org/wiki/Graph_search_algorithm">Graph Search Algorithms</a>.</p>

<h2>Dijkstra's Algorithm</h2>

<p>We would also like the flowlines to look aesthetically pleasing. Although its slightly difficult
to define, mathematically, what could be aesthetically pleasing, i reason that the
following two parameters can create good flowlines.</p>

<ol>
<li><em>Minimize Path Length</em> : Obviously, shorter lines connecting chart components are easier to
read.</li>
<li><em>Minimize Bends</em>  : Connecting lines which have too many bends are hard to follow. The
problem with orthogonal paths is that the shortest distance between any two points is
given by <a href="http://en.wikipedia.org/wiki/Manhattan_distance">manhattan distance</a>. This means that there could be several paths with
shortest length. In the absence of obstacles, any of the shortest path can have atmost
about min(abs(x'-x), abs(y'-y)) bends (blind guess formula no proofs :P), therefore
minimizing bends is important.</li>
</ol>

<p>For a given path, if we define path cost function g(n) as the sum of distance to node n from
starting point along the given path and the number of bends along the path from starting point
to n, then we would like our algorithm the choose the path with least path cost function for
the end point. We use the <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">dijkstra's algorithm</a> with path cost = g(n) = distance + #of bends
to do this.</p>

<p>The problem with this approach is that, standard Dijkstra algorithm works by extending optimal
partial paths. In simple graph search, when there are several optimal partial paths of the same
cost, the choice between one of these for extension doesnt affect the optimality of the final
path. But however, in our case, this is not true (again, due to the <a href="http://en.wikipedia.org/wiki/Manhattan_distance">Taxicab Geometry</a>).
Consider the following:</p>

<pre><code>A----(B)
|     |
|     |
|     |
D-----C
|
|
|
(E)
</code></pre>

<p>We are trying to connect B to E. At point D, there are two optimal partial paths
BAD and BCD of the same cost (cost=length+bends=2+1). If the algorithm
chooses path BCD for extension the final path BCDE(cost=length+bends=3+2) is suboptimal since
there is path BADE(cost=length+bends=3+1) with fewer bends. Thus we need to teach our algorithm
to make the choice in such a way that the extended path is also optimal.</p>

<p>In Dijkstra, we extend a path to a node only if the optimal partial path (if one has aleady
been computed) at that point, from the start, has greater cost than the new path that
would be generated after extension. If we introduce an estimate of the minimum number of bends
required to reach the target also in the above condition ie. we extend only if the sum of cost
of optimal partial path and estimate of min bends to target is greater than that for the new
path that would be generated, then we can avoid the previously mentioned problem. Thus, in the
previous example, if path BAD has already been computed and BC is being considered, then we do
not extend BC to BCD since atleast 1 more bend is required to reach E along BCD wheras BAD 
requires no more bends to reach E. Conversely, if BCD has already been computed and BA is being
considered, then we detach D from BCD and extend BA to BAD since it has lower bends estimate.</p>

<p>The minimum bends-to-target estimate can be easily computed by checking the direction of the partial
path at the end point and the relative position of the target eg: if target is along same direction
and in front of the end point then min-bends-to-target is 0, there are three other such cases.</p>

<h2>Making it Faster</h2>

<p>Dijkstra's algorithm is sort of like hitting the pinata, it'd go about searching all over the
canvas to find the end point. If we have some more information about how warm or cold each point
is, with respect to the target, we can avoid searching in directions that we know to be less
likely to lead us to the endpoint. We do this by implementing an <a href="http://en.wikipedia.org/wiki/A-star_algorithm">A* Search</a>, which is a generalization
of Dijkstra. We use a heuristic function h(n) = manhattan-distance(n,target)+min-bends(n,target),
so that the search would try find paths within or close to a rectangle with the start and end points
at opposite corners and are likely to have fewer bends.</p>

<h2>Implementation</h2>

<p><img src="/posts/images/dijkstra_demo.png" alt="Dijkstra implementation screenshot" /></p>

<div data-gist-id="1521549"><a href="http://gist.github.com/1521549">Flow Chart Edge Routing Gist</a></div>

<p><a href="https://gist.github.com/1521549">This</a> is a hacky little demo with animation. Hit the play button to run the animation.
Red dots are nodes which have been considered and Yellow dots are the nodes in the queue. 
Uncomment <code>n.heuristic = 0;</code> line in dijkstra function to switch to simple dijkstra without
A*.</p>

<h2>The Wheel </h2>

<p>A very interesting optimization to this is to reduce the search to the orthogonal
visibility Graph (a graph containing points of interest, such as vertices, with arcs drawn
between nodes that can see each other). This and a more formal approach to this problem is
detailed in this paper: <a href="http://ww2.cs.mu.oz.au/~pjs/papers/gd09.pdf">Orthogonal Connector Routing</a>. The Authors of the paper have
a C++ implementation of their technique in <a href="http://adaptagrams.sourceforge.net/libavoid/">libavoid</a> libaray.</p>

<p>I dot not have proofs for the correctness, optimality etc. for anything, though it seems to
work in the simple prototype. Any comments are welcome.</p>

                    ]]>
                </description>
            </item>
            <item>
                <title>N Queens Puzzle</title>
                <link>http://azeemarshad.in/posts/n-queens-puzzle.html</link>
                <guid>http://azeemarshad.in/posts/n-queens-puzzle.html</guid>
                <description>
                    <![CDATA[
                        <p>I've been reading this great book, <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation 
of Computer Programs</a> for the last few days. The examples are full of really cool math, algorithms, techniques and stuff. Here is an exercise that i managed to solve in scheme, The <a href="http://en.wikipedia.org/wiki/N-queens">Eight queens puzzle</a>.</p>

<blockquote>
  <p>The eight queens puzzle is the problem of putting eight chess queens on an 8x8 chessboard such that none of them is able to capture any other using the standard chess queen's moves.</p>
</blockquote>

<p>And here is the source.</p>

<pre><code>(define (range a b)
  (if (= a b)
      null
      (cons a (range (+ a 1) b))))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (flatmap proc seq)
  (accumulate append null (map proc seq)))

(define (enumerate sequence)
  (define (iter counter sequence)
    (if (null? sequence)
        null
        (append (list (cons counter (car sequence))) (iter (+ counter 1) (cdr sequence)))))
  (iter 0 sequence))

(define (rook-attack-safe? possibilities)
  (accumulate (lambda (a b) (and a b))
              true
              (map (lambda (possibility)
                     (not (= possibility (last possibilities))))
                   (cdr (reverse possibilities)))))

(define (bishop-attack-safe? possibilities)
  (accumulate (lambda (a b) (and a b))
              true
              (map (lambda (pair)
                     (not (= (abs (- (last possibilities) (cdr pair)))
                             (abs (- (- (length possibilities) 1) (car pair))))))
                   (enumerate (reverse (cdr (reverse possibilities)))))))

(define (safe? possibilities)
  (and (rook-attack-safe? possibilities)
       (bishop-attack-safe? possibilities)))

(define (n-queens-puzzle k)
  (define (solve n k)
    (if (= n 0)
        '(())
        (filter safe?
               (flatmap (lambda (last)
                          (map (lambda (item)
                                 (append item (list last)))
                               (solve (- n 1) k)))
                        (range 0 k)))))
  (solve k k))
</code></pre>

<p>Please excuse the crappy code. Im a total noob schemer, infact this is probably my first real scheme program. The solution is based on the recursive method described in the book. It works like this: only one queen can be placed in any one column, the problem of placing queens in all columns without any check can be reduced, using recursion, to that of placing a queen in the last column of a board in which all the other columns already have queens in positions that do not check each other.</p>

<p>It took quite some time to solve an 8x8 board. Im not even sure if the results are correct. But a few random checks on paper turned out correct and i got 92 results, which according to wikipedia is the total number of solutions. However, there are only 12 unique solutions, many of the 92 solutions are repetitions since one solution can be horizontally or vertically flipped to create different solutions. Each solution here is a list whose indices correspond to the board column number and the values represent the row in which the queen is placed in the corresponding column.</p>

<pre><code>((3 1 6 2 5 7 4 0)
 (4 1 3 6 2 7 5 0)
 (2 4 1 7 5 3 6 0)
 (2 5 3 1 7 4 6 0)
 (4 6 0 2 7 5 3 1)
 (3 5 7 2 0 6 4 1)
 (2 5 7 0 3 6 4 1)
 (4 2 7 3 6 0 5 1)
 (4 6 3 0 2 7 5 1)
 (3 0 4 7 5 2 6 1)
 (2 5 3 0 7 4 6 1)
 (3 6 4 2 0 5 7 1)
 (5 3 1 7 4 6 0 2)
 (5 3 6 0 7 1 4 2)
 (0 6 3 5 7 1 4 2)
 (5 7 1 3 0 6 4 2)
 (5 1 6 0 3 7 4 2)
 (3 6 0 7 4 1 5 2)
 (4 7 3 0 6 1 5 2)
 (3 7 0 4 6 1 5 2)
 (1 6 4 7 0 3 5 2)
 (0 6 4 7 1 3 5 2)
 (1 4 6 3 0 7 5 2)
 (3 1 6 4 0 7 5 2)
 (4 6 0 3 1 7 5 2)
 (5 3 0 4 7 1 6 2)
 (4 0 3 5 7 1 6 2)
 (4 1 5 0 6 3 7 2)
 (5 2 6 1 7 4 0 3)
 (1 6 2 5 7 4 0 3)
 (6 2 0 5 7 4 1 3)
 (4 0 7 5 2 6 1 3)
 (0 4 7 5 2 6 1 3)
 (2 5 7 0 4 6 1 3)
 (5 2 0 6 4 7 1 3)
 (6 4 2 0 5 7 1 3)
 (6 2 7 1 4 0 5 3)
 (4 2 0 6 1 7 5 3)
 (1 4 6 0 2 7 5 3)
 (2 5 1 4 7 0 6 3)
 (5 0 4 1 7 2 6 3)
 (7 2 0 5 1 4 6 3)
 (1 7 5 0 2 4 6 3)
 (4 6 1 5 2 0 7 3)
 (2 5 1 6 4 0 7 3)
 (5 1 6 0 2 4 7 3)
 (2 6 1 7 5 3 0 4)
 (5 2 6 1 3 7 0 4)
 (3 1 6 2 5 7 0 4)
 (6 0 2 7 5 3 1 4)
 (0 5 7 2 6 3 1 4)
 (2 7 3 6 0 5 1 4)
 (5 2 6 3 0 7 1 4)
 (6 3 1 7 5 0 2 4)
 (3 5 7 1 6 0 2 4)
 (1 5 0 6 3 7 2 4)
 (1 3 5 7 2 0 6 4)
 (2 5 7 1 3 0 6 4)
 (5 2 0 7 3 1 6 4)
 (7 3 0 2 5 1 6 4)
 (3 7 0 2 5 1 6 4)
 (1 5 7 2 0 3 6 4)
 (6 1 5 2 0 3 7 4)
 (2 5 1 6 0 3 7 4)
 (3 6 2 7 1 4 0 5)
 (3 7 4 2 0 6 1 5)
 (2 4 7 3 0 6 1 5)
 (3 1 7 4 6 0 2 5)
 (4 6 1 3 7 0 2 5)
 (6 3 1 4 7 0 2 5)
 (7 1 3 0 6 4 2 5)
 (6 1 3 0 7 4 2 5)
 (4 0 7 3 1 6 2 5)
 (3 0 4 7 1 6 2 5)
 (4 1 7 0 3 6 2 5)
 (2 6 1 7 4 0 3 5)
 (2 0 6 4 7 1 3 5)
 (7 1 4 2 0 6 3 5)
 (2 4 1 7 0 6 3 5)
 (2 4 6 0 3 1 7 5)
 (4 1 3 5 7 2 0 6)
 (5 2 4 7 0 3 1 6)
 (4 7 3 0 2 5 1 6)
 (3 1 4 7 5 0 2 6)
 (3 5 0 4 1 7 2 6)
 (5 2 0 7 4 1 3 6)
 (4 2 0 5 7 1 3 6)
 (3 1 7 5 0 2 4 6)
 (5 2 4 6 0 3 1 7)
 (5 3 6 0 2 4 1 7)
 (3 6 4 1 5 0 2 7)
 (4 6 1 5 2 0 3 7))
</code></pre>

<p><a href="http://community.schemewiki.org/?sicp-ex-2.42">Better solutions</a></p>

                    ]]>
                </description>
            </item>
    </channel>
</rss>
