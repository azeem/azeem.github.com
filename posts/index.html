<!DOCTYPE HTML PUBLIC "-//w3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <title>Azeem Arshad</title>
        <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://azeemarshad.in/posts/feed.rss" />
    </head>
    <body>
        <div id="container">
            <div id="header">
                <ul class="navmenu"><li class=""><a href="/posts/">Blog</a></li><li class=""><a href="/posts/feed.rss">Feed</a></li><li class=""><a href="/about.html">About</a></li></ul>
                <h1>Azeem Arshad</h1>
            </div>
            
            <div id="main" class="blog">
                
            <div class="post">
                <div class="post-head">
                    <h1><a href="/posts/edge_routing_with_dijkstra.html">Flowchart edge routing with Dijkstra</a></h1>
                    <div class="pub-time">Dec 26 2011</div>
                </div>
                <div class="post-body">
                    <p>I have been trying to find some interesting coding stuff to work on, something to get off of the
monotonous work that i do at my day job, relive the college days :P. This is an interesting
problem that came up when i tried to dust off one of my old javascript projects. In simple words, the
problem goes something like this: given a flow chart, how do you automatically render orthogonal
flow lines without intersections or collisions.</p>

<p><a href="http://pipes.yahoo.com/pipes/">Yahoo pipes</a> was sort of like a reference design for my project. But i wanted clean
orthogonal connecting lines that avoided each other, unlike the curvy pipes that would go
behind components. Interestingly, i could find some nice javascript libraries, <a href="http://neyric.github.com/wireit/">WireIt</a> and
<a href="http://jsplumb.org/jquery/demo.html">jsPlumb</a>, that takes care of rendering pipes/connections etc. Regardless, in the DIY spirit,
(or rather, the Reinvent The Wheel Yourself spirit :P) i started to prototype.</p>

<p>The underlying problem is path search. A 2D canvas can be treated as a <a href="http://en.wikipedia.org/wiki/Graph_(mathematics)">Graph</a>, where each
pixel is represented by a node (lets say we represent a pixel (x,y) with node [x,y]). Obviously, pixels
that collide with chart components or other flowlines will have no corresponding nodes. Since
we are interested only in orthogonal paths, we create edges from each node to its four
orthogonal neighbours (ie. [x,y-1], [x-1,y], [x,y+1], [x+1,y]). The problem of finding
orthogonal flow line from point (x,y) to (x',y') can now be treated as the problem of finding
a path from node [x,y] to [x',y'], which can be easily solved by <a href="http://en.wikipedia.org/wiki/Graph_search_algorithm">Graph Search Algorithms</a>.</p>

<h2>Dijkstra</h2>

<p>We would also like the flowlines to look aesthetically pleasing. Although its slightly difficult
to define, mathematically, what could be aesthetically pleasing, i reason that the
following two parameters can create good flowlines.</p>

<ol>
<li><em>Minimize Path Length</em> : Obviously, shorter lines connecting chart components are easier to
read.</li>
<li><em>Minimize Bends</em>  : Connecting lines which have too many bends are hard to follow. The
problem with orthogonal paths is that the shortest distance between any two points is
given by <a href="http://en.wikipedia.org/wiki/Manhattan_distance">manhattan distance</a>. This means that there could be several paths with
shortest length. In the absence of obstacles, any of the shortest path can have atmost
about min(abs(x'-x), abs(y'-y)) bends (blind guess formula no proofs :P), therefore
minimizing bends is important.</li>
</ol>

<p>For a given path, if we define path cost function g(n) as the sum of distance to node n from
starting point along the given path and the number of bends along the path from starting point
to n, then we would like our algorithm the choose the path with least path cost function for
the end point. We use the <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">dijkstra's algorithm</a> with path cost = g(n) = distance + #of bends
to do this.</p>

<h2>Making it Faster</h2>

<p>Dijkstra's algorithm is sort of like hitting the pinata, it'd go about searching all over the
canvas to find the end point. If we have some more information about how warm or cold each point
is, with respect to the target, we can avoid searching in directions that we know would surely
not lead us to the endpoint. We do this using the <a href="http://en.wikipedia.org/wiki/A-star_algorithm">A* Algorithm</a>, which is a generalization
of Dijkstra. We use a heuristic function h(n) = manhattan_distance((x,y), (x',y')), so that
the search would try to stay within or close to a rectangle with the start and end points at
opposite corners.</p>

<h2>Implementation</h2>

<p><img src="/posts/images/dijkstra_demo.png" alt="Dijkstra implementation screenshot" /></p>

<script src="https://gist.github.com/1521549.js"></script>

<p><a href="https://gist.github.com/1521549">This</a> is a hacky little demo with animation. Hit start button to run the animation.
Red dots are nodes which have been considered and Yellow dots are the nodes in the queue. 
Uncomment <code>return 0;</code> line in manhattan_distance function to switch to simple dijkstra.</p>

                </div>
            </div>
            <div class="post">
                <div class="post-head">
                    <h1><a href="/posts/n-queens-puzzle.html">N Queens Puzzle</a></h1>
                    <div class="pub-time">Jul 22 2009</div>
                </div>
                <div class="post-body">
                    <p>I've been reading this great book, <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation 
of Computer Programs</a> for the last few days. The examples are full of really cool math, algorithms, techniques and stuff. Here is an exercise that i managed to solve in scheme, The <a href="http://en.wikipedia.org/wiki/N-queens">Eight queens puzzle</a>.</p>

<blockquote>
  <p>The eight queens puzzle is the problem of putting eight chess queens on an 8x8 chessboard such that none of them is able to capture any other using the standard chess queen's moves.</p>
</blockquote>

<p>And here is the source.</p>

<pre><code>(define (range a b)
  (if (= a b)
      null
      (cons a (range (+ a 1) b))))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (flatmap proc seq)
  (accumulate append null (map proc seq)))

(define (enumerate sequence)
  (define (iter counter sequence)
    (if (null? sequence)
        null
        (append (list (cons counter (car sequence))) (iter (+ counter 1) (cdr sequence)))))
  (iter 0 sequence))

(define (rook-attack-safe? possibilities)
  (accumulate (lambda (a b) (and a b))
              true
              (map (lambda (possibility)
                     (not (= possibility (last possibilities))))
                   (cdr (reverse possibilities)))))

(define (bishop-attack-safe? possibilities)
  (accumulate (lambda (a b) (and a b))
              true
              (map (lambda (pair)
                     (not (= (abs (- (last possibilities) (cdr pair)))
                             (abs (- (- (length possibilities) 1) (car pair))))))
                   (enumerate (reverse (cdr (reverse possibilities)))))))

(define (safe? possibilities)
  (and (rook-attack-safe? possibilities)
       (bishop-attack-safe? possibilities)))

(define (n-queens-puzzle k)
  (define (solve n k)
    (if (= n 0)
        '(())
        (filter safe?
               (flatmap (lambda (last)
                          (map (lambda (item)
                                 (append item (list last)))
                               (solve (- n 1) k)))
                        (range 0 k)))))
  (solve k k))
</code></pre>

<p>Please excuse the crappy code. Im a total noob schemer, infact this is probably my first real scheme program. The solution is based on the recursive method described in the book. It works like this: only one queen can be placed in any one column, the problem of placing queens in all columns without any check can be reduced, using recursion, to that of placing a queen in the last column of a board in which all the other columns already have queens in positions that do not check each other.</p>

<p>It took quite some time to solve an 8x8 board. Im not even sure if the results are correct. But a few random checks on paper turned out correct and i got 92 results, which according to wikipedia is the total number of solutions. However, there are only 12 unique solutions, many of the 92 solutions are repetitions since one solution can be horizontally or vertically flipped to create different solutions. Each solution here is a list whose indices correspond to the board column number and the values represent the row in which the queen is placed in the corresponding column.</p>

<pre><code>((3 1 6 2 5 7 4 0)
 (4 1 3 6 2 7 5 0)
 (2 4 1 7 5 3 6 0)
 (2 5 3 1 7 4 6 0)
 (4 6 0 2 7 5 3 1)
 (3 5 7 2 0 6 4 1)
 (2 5 7 0 3 6 4 1)
 (4 2 7 3 6 0 5 1)
 (4 6 3 0 2 7 5 1)
 (3 0 4 7 5 2 6 1)
 (2 5 3 0 7 4 6 1)
 (3 6 4 2 0 5 7 1)
 (5 3 1 7 4 6 0 2)
 (5 3 6 0 7 1 4 2)
 (0 6 3 5 7 1 4 2)
 (5 7 1 3 0 6 4 2)
 (5 1 6 0 3 7 4 2)
 (3 6 0 7 4 1 5 2)
 (4 7 3 0 6 1 5 2)
 (3 7 0 4 6 1 5 2)
 (1 6 4 7 0 3 5 2)
 (0 6 4 7 1 3 5 2)
 (1 4 6 3 0 7 5 2)
 (3 1 6 4 0 7 5 2)
 (4 6 0 3 1 7 5 2)
 (5 3 0 4 7 1 6 2)
 (4 0 3 5 7 1 6 2)
 (4 1 5 0 6 3 7 2)
 (5 2 6 1 7 4 0 3)
 (1 6 2 5 7 4 0 3)
 (6 2 0 5 7 4 1 3)
 (4 0 7 5 2 6 1 3)
 (0 4 7 5 2 6 1 3)
 (2 5 7 0 4 6 1 3)
 (5 2 0 6 4 7 1 3)
 (6 4 2 0 5 7 1 3)
 (6 2 7 1 4 0 5 3)
 (4 2 0 6 1 7 5 3)
 (1 4 6 0 2 7 5 3)
 (2 5 1 4 7 0 6 3)
 (5 0 4 1 7 2 6 3)
 (7 2 0 5 1 4 6 3)
 (1 7 5 0 2 4 6 3)
 (4 6 1 5 2 0 7 3)
 (2 5 1 6 4 0 7 3)
 (5 1 6 0 2 4 7 3)
 (2 6 1 7 5 3 0 4)
 (5 2 6 1 3 7 0 4)
 (3 1 6 2 5 7 0 4)
 (6 0 2 7 5 3 1 4)
 (0 5 7 2 6 3 1 4)
 (2 7 3 6 0 5 1 4)
 (5 2 6 3 0 7 1 4)
 (6 3 1 7 5 0 2 4)
 (3 5 7 1 6 0 2 4)
 (1 5 0 6 3 7 2 4)
 (1 3 5 7 2 0 6 4)
 (2 5 7 1 3 0 6 4)
 (5 2 0 7 3 1 6 4)
 (7 3 0 2 5 1 6 4)
 (3 7 0 2 5 1 6 4)
 (1 5 7 2 0 3 6 4)
 (6 1 5 2 0 3 7 4)
 (2 5 1 6 0 3 7 4)
 (3 6 2 7 1 4 0 5)
 (3 7 4 2 0 6 1 5)
 (2 4 7 3 0 6 1 5)
 (3 1 7 4 6 0 2 5)
 (4 6 1 3 7 0 2 5)
 (6 3 1 4 7 0 2 5)
 (7 1 3 0 6 4 2 5)
 (6 1 3 0 7 4 2 5)
 (4 0 7 3 1 6 2 5)
 (3 0 4 7 1 6 2 5)
 (4 1 7 0 3 6 2 5)
 (2 6 1 7 4 0 3 5)
 (2 0 6 4 7 1 3 5)
 (7 1 4 2 0 6 3 5)
 (2 4 1 7 0 6 3 5)
 (2 4 6 0 3 1 7 5)
 (4 1 3 5 7 2 0 6)
 (5 2 4 7 0 3 1 6)
 (4 7 3 0 2 5 1 6)
 (3 1 4 7 5 0 2 6)
 (3 5 0 4 1 7 2 6)
 (5 2 0 7 4 1 3 6)
 (4 2 0 5 7 1 3 6)
 (3 1 7 5 0 2 4 6)
 (5 2 4 6 0 3 1 7)
 (5 3 6 0 2 4 1 7)
 (3 6 4 1 5 0 2 7)
 (4 6 1 5 2 0 3 7))
</code></pre>

<p><a href="http://community.schemewiki.org/?sicp-ex-2.42">Better solutions</a></p>

                </div>
            </div>
        <div class="bottom-nav">
            <a href="/posts/archive/">More...</a>
        </div>

            </div>
        </div>
    </body>
</html>



