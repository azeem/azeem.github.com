<!DOCTYPE HTML PUBLIC "-//w3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <title>Flowchart edge routing with Dijkstra|Azeem Arshad</title>
        <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://azeemarshad.in/posts/feed.rss" />
    </head>
    <body>
        <div id="container">
            <div id="header">
                <ul class="navmenu"><li class=""><a href="/posts/">Blog</a></li><li class=""><a href="/posts/feed.rss">Feed</a></li><li class=""><a href="/about.html">About</a></li></ul>
                <h1>Azeem Arshad</h1>
            </div>
            
            <div id="main" class="blog">
                
    
    <div class="post">
        <div class="post-head">
            <h1>Flowchart edge routing with Dijkstra</h1>
            <div class="pub-time">Monday, 26 December 2011, 0706 hours</div>
        </div>
        <div class="post-body">
            <p>I have been trying to find some interesting coding stuff to work on, something to get off of the
monotonous work that i do at my day job, relive the college days :P. This is an interesting
problem that came up when i tried to dust off one of my old javascript projects. In simple words, the
problem goes something like this: given a flow chart, how do you automatically render orthogonal
flow lines without intersections or collisions.</p>

<p><a href="http://pipes.yahoo.com/pipes/">Yahoo pipes</a> was sort of like a reference design for my project. But i wanted clean
orthogonal connecting lines that avoided each other, unlike the curvy pipes that would go
behind components. Interestingly, i could find some nice javascript libraries, <a href="http://neyric.github.com/wireit/">WireIt</a> and
<a href="http://jsplumb.org/jquery/demo.html">jsPlumb</a>, that takes care of rendering pipes/connections etc. Regardless, in the DIY spirit,
(or rather, the Reinvent The Wheel Yourself spirit :P) i started to prototype.</p>

<p>The underlying problem is path search. A 2D canvas can be treated as a <a href="http://en.wikipedia.org/wiki/Graph_(mathematics)">Graph</a>, where each
pixel is represented by a node (lets say we represent a pixel (x,y) with node [x,y]). Obviously, pixels
that collide with chart components or other flowlines will have no corresponding nodes. Since
we are interested only in orthogonal paths, we create edges from each node to its four
orthogonal neighbours (ie. [x,y-1], [x-1,y], [x,y+1], [x+1,y]). The problem of finding
orthogonal flow line from point (x,y) to (x',y') can now be treated as the problem of finding
a path from node [x,y] to [x',y'], which can be easily solved by <a href="http://en.wikipedia.org/wiki/Graph_search_algorithm">Graph Search Algorithms</a>.</p>

<h2>Dijkstra</h2>

<p>We would also like the flowlines to look aesthetically pleasing. Although its slightly difficult
to define, mathematically, what could be aesthetically pleasing, i reason that the
following two parameters can create good flowlines.</p>

<ol>
<li><em>Minimize Path Length</em> : Obviously, shorter lines connecting chart components are easier to
read.</li>
<li><em>Minimize Bends</em>  : Connecting lines which have too many bends are hard to follow. The
problem with orthogonal paths is that the shortest distance between any two points is
given by <a href="http://en.wikipedia.org/wiki/Manhattan_distance">manhattan distance</a>. This means that there could be several paths with
shortest length. In the absence of obstacles, any of the shortest path can have atmost
about min(abs(x'-x), abs(y'-y)) bends (blind guess formula no proofs :P), therefore
minimizing bends is important.</li>
</ol>

<p>For a given path, if we define path cost function g(n) as the sum of distance to node n from
starting point along the given path and the number of bends along the path from starting point
to n, then we would like our algorithm the choose the path with least path cost function for
the end point. We use the <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">dijkstra's algorithm</a> with path cost = g(n) = distance + #of bends
to do this.</p>

<h2>Making it Faster</h2>

<p>Dijkstra's algorithm is sort of like hitting the pinata, it'd go about searching all over the
canvas to find the end point. If we have some more information about how warm or cold each point
is, with respect to the target, we can avoid searching in directions that we know would surely
not lead us to the endpoint. We do this using the <a href="http://en.wikipedia.org/wiki/A-star_algorithm">A* Algorithm</a>, which is a generalization
of Dijkstra. We use a heuristic function h(n) = manhattan_distance((x,y), (x',y')), so that
the search would try to stay within or close to a rectangle with the start and end points at
opposite corners.</p>

<h2>Implementation</h2>

<p><img src="/posts/images/dijkstra_demo.png" alt="Dijkstra implementation screenshot" /></p>

<script src="https://gist.github.com/1521549.js"></script>

<p><a href="https://gist.github.com/1521549">This</a> is a hacky little demo with animation. Hit start button to run the animation.
Red dots are nodes which have been considered and Yellow dots are the nodes in the queue. 
Uncomment <code>return 0;</code> line in manhattan_distance function to switch to simple dijkstra.</p>

        </div>
        <div class="bottom-nav">
            <a href="/posts/">&larr; Blog</a> &#8226;
            <a href="/posts/archive/">More...</a>
        </div>
    </div>

            </div>
        </div>
    </body>
</html>



